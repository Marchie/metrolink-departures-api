// Code generated by MockGen. DO NOT EDIT.
// Source: /Users/marchie/go/pkg/mod/github.com/gomodule/redigo@v2.0.0+incompatible/redis/redis.go

// Package mock_redis is a generated GoMock package.
package mock_redis

import (
	gomock "github.com/golang/mock/gomock"
	reflect "reflect"
	time "time"
)

// MockConn is a mock of Conn interface
type MockConn struct {
	ctrl     *gomock.Controller
	recorder *MockConnMockRecorder
}

// MockConnMockRecorder is the mock recorder for MockConn
type MockConnMockRecorder struct {
	mock *MockConn
}

// NewMockConn creates a new mock instance
func NewMockConn(ctrl *gomock.Controller) *MockConn {
	mock := &MockConn{ctrl: ctrl}
	mock.recorder = &MockConnMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockConn) EXPECT() *MockConnMockRecorder {
	return m.recorder
}

// Close mocks base method
func (m *MockConn) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close
func (mr *MockConnMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockConn)(nil).Close))
}

// Err mocks base method
func (m *MockConn) Err() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Err")
	ret0, _ := ret[0].(error)
	return ret0
}

// Err indicates an expected call of Err
func (mr *MockConnMockRecorder) Err() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Err", reflect.TypeOf((*MockConn)(nil).Err))
}

// Do mocks base method
func (m *MockConn) Do(commandName string, args ...interface{}) (interface{}, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{commandName}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Do", varargs...)
	ret0, _ := ret[0].(interface{})
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Do indicates an expected call of Do
func (mr *MockConnMockRecorder) Do(commandName interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{commandName}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Do", reflect.TypeOf((*MockConn)(nil).Do), varargs...)
}

// Send mocks base method
func (m *MockConn) Send(commandName string, args ...interface{}) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{commandName}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Send", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Send indicates an expected call of Send
func (mr *MockConnMockRecorder) Send(commandName interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{commandName}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Send", reflect.TypeOf((*MockConn)(nil).Send), varargs...)
}

// Flush mocks base method
func (m *MockConn) Flush() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Flush")
	ret0, _ := ret[0].(error)
	return ret0
}

// Flush indicates an expected call of Flush
func (mr *MockConnMockRecorder) Flush() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Flush", reflect.TypeOf((*MockConn)(nil).Flush))
}

// Receive mocks base method
func (m *MockConn) Receive() (interface{}, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Receive")
	ret0, _ := ret[0].(interface{})
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Receive indicates an expected call of Receive
func (mr *MockConnMockRecorder) Receive() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Receive", reflect.TypeOf((*MockConn)(nil).Receive))
}

// MockArgument is a mock of Argument interface
type MockArgument struct {
	ctrl     *gomock.Controller
	recorder *MockArgumentMockRecorder
}

// MockArgumentMockRecorder is the mock recorder for MockArgument
type MockArgumentMockRecorder struct {
	mock *MockArgument
}

// NewMockArgument creates a new mock instance
func NewMockArgument(ctrl *gomock.Controller) *MockArgument {
	mock := &MockArgument{ctrl: ctrl}
	mock.recorder = &MockArgumentMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockArgument) EXPECT() *MockArgumentMockRecorder {
	return m.recorder
}

// RedisArg mocks base method
func (m *MockArgument) RedisArg() interface{} {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RedisArg")
	ret0, _ := ret[0].(interface{})
	return ret0
}

// RedisArg indicates an expected call of RedisArg
func (mr *MockArgumentMockRecorder) RedisArg() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RedisArg", reflect.TypeOf((*MockArgument)(nil).RedisArg))
}

// MockScanner is a mock of Scanner interface
type MockScanner struct {
	ctrl     *gomock.Controller
	recorder *MockScannerMockRecorder
}

// MockScannerMockRecorder is the mock recorder for MockScanner
type MockScannerMockRecorder struct {
	mock *MockScanner
}

// NewMockScanner creates a new mock instance
func NewMockScanner(ctrl *gomock.Controller) *MockScanner {
	mock := &MockScanner{ctrl: ctrl}
	mock.recorder = &MockScannerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockScanner) EXPECT() *MockScannerMockRecorder {
	return m.recorder
}

// RedisScan mocks base method
func (m *MockScanner) RedisScan(src interface{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RedisScan", src)
	ret0, _ := ret[0].(error)
	return ret0
}

// RedisScan indicates an expected call of RedisScan
func (mr *MockScannerMockRecorder) RedisScan(src interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RedisScan", reflect.TypeOf((*MockScanner)(nil).RedisScan), src)
}

// MockConnWithTimeout is a mock of ConnWithTimeout interface
type MockConnWithTimeout struct {
	ctrl     *gomock.Controller
	recorder *MockConnWithTimeoutMockRecorder
}

// MockConnWithTimeoutMockRecorder is the mock recorder for MockConnWithTimeout
type MockConnWithTimeoutMockRecorder struct {
	mock *MockConnWithTimeout
}

// NewMockConnWithTimeout creates a new mock instance
func NewMockConnWithTimeout(ctrl *gomock.Controller) *MockConnWithTimeout {
	mock := &MockConnWithTimeout{ctrl: ctrl}
	mock.recorder = &MockConnWithTimeoutMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockConnWithTimeout) EXPECT() *MockConnWithTimeoutMockRecorder {
	return m.recorder
}

// Close mocks base method
func (m *MockConnWithTimeout) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close
func (mr *MockConnWithTimeoutMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockConnWithTimeout)(nil).Close))
}

// Err mocks base method
func (m *MockConnWithTimeout) Err() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Err")
	ret0, _ := ret[0].(error)
	return ret0
}

// Err indicates an expected call of Err
func (mr *MockConnWithTimeoutMockRecorder) Err() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Err", reflect.TypeOf((*MockConnWithTimeout)(nil).Err))
}

// Do mocks base method
func (m *MockConnWithTimeout) Do(commandName string, args ...interface{}) (interface{}, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{commandName}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Do", varargs...)
	ret0, _ := ret[0].(interface{})
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Do indicates an expected call of Do
func (mr *MockConnWithTimeoutMockRecorder) Do(commandName interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{commandName}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Do", reflect.TypeOf((*MockConnWithTimeout)(nil).Do), varargs...)
}

// Send mocks base method
func (m *MockConnWithTimeout) Send(commandName string, args ...interface{}) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{commandName}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Send", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Send indicates an expected call of Send
func (mr *MockConnWithTimeoutMockRecorder) Send(commandName interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{commandName}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Send", reflect.TypeOf((*MockConnWithTimeout)(nil).Send), varargs...)
}

// Flush mocks base method
func (m *MockConnWithTimeout) Flush() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Flush")
	ret0, _ := ret[0].(error)
	return ret0
}

// Flush indicates an expected call of Flush
func (mr *MockConnWithTimeoutMockRecorder) Flush() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Flush", reflect.TypeOf((*MockConnWithTimeout)(nil).Flush))
}

// Receive mocks base method
func (m *MockConnWithTimeout) Receive() (interface{}, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Receive")
	ret0, _ := ret[0].(interface{})
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Receive indicates an expected call of Receive
func (mr *MockConnWithTimeoutMockRecorder) Receive() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Receive", reflect.TypeOf((*MockConnWithTimeout)(nil).Receive))
}

// DoWithTimeout mocks base method
func (m *MockConnWithTimeout) DoWithTimeout(timeout time.Duration, commandName string, args ...interface{}) (interface{}, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{timeout, commandName}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DoWithTimeout", varargs...)
	ret0, _ := ret[0].(interface{})
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DoWithTimeout indicates an expected call of DoWithTimeout
func (mr *MockConnWithTimeoutMockRecorder) DoWithTimeout(timeout, commandName interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{timeout, commandName}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DoWithTimeout", reflect.TypeOf((*MockConnWithTimeout)(nil).DoWithTimeout), varargs...)
}

// ReceiveWithTimeout mocks base method
func (m *MockConnWithTimeout) ReceiveWithTimeout(timeout time.Duration) (interface{}, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReceiveWithTimeout", timeout)
	ret0, _ := ret[0].(interface{})
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReceiveWithTimeout indicates an expected call of ReceiveWithTimeout
func (mr *MockConnWithTimeoutMockRecorder) ReceiveWithTimeout(timeout interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReceiveWithTimeout", reflect.TypeOf((*MockConnWithTimeout)(nil).ReceiveWithTimeout), timeout)
}
